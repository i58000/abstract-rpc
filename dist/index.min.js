!function(e,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports):"function"==typeof define&&define.amd?define(["exports"],s):s((e="undefined"!=typeof globalThis?globalThis:e||self).AbstractRPC={})}(this,(function(e){"use strict";var s;!function(e){e.REQUSET="request",e.RESPONSE="response"}(s||(s={}));class t{constructor({payload:e,meta:s,type:t}){this.payload=e,this.meta=s,this.type=t}}class r{constructor(){if(this._messageMeta="rpc",this._isReady=!1,this._requestMap={},this._procedureMap={},!this.addMessageListener)throw new Error("this RPC instance has no `addMessageListener` method, please implement it correctly.");if(!this.removeMessageListener)throw new Error("this RPC instance has no `removeMessageListener` method, please implement it correctly.");if(!this.postMessage)throw new Error("this RPC instance has no `postMessage` method, please implement it correctly.")}start(){if(this._isReady)throw new Error("this RPC instance has started, do not start again.");this.addMessageListener(this._messagelistener.bind(this)),this._isReady=!0}stop(){if(!this._isReady)throw new Error("this RPC instance has not started, unable to stop it.");this.removeMessageListener(this._messagelistener.bind(this)),this._isReady=!1}async call(e,r){if(!this._isReady)throw new Error("this RPC instance is not ready, start it please.");return new Promise((async(i,o)=>{const n=a()+a(),l={uuid:n,name:e,value:r,timestamp:(new Date).getTime()};this._requestMap[n]={payload:l,resolve:i,reject:o},this.postMessage(new t({payload:l,meta:this._messageMeta,type:s.REQUSET}))}))}procedure(e,s){s?(this._procedureMap[e]&&i("this name of procedure is registered, replace it."),this._procedureMap[e]=s):delete this._procedureMap[e]}async _messagelistener(e){const{type:t,meta:r,payload:a}=e;if(r===this._messageMeta)switch(t){case s.REQUSET:this._resolveRequest(a);break;case s.RESPONSE:this._resolveResponse(a);break;default:throw new Error(`unknown message type: ${t}`)}}async _resolveRequest({uuid:e,value:r,name:a}){const i={uuid:e,name:a,state:"pending",value:void 0};try{o(`[${this.label()}] callee: procedure \`${a}\`[${e}] is being called with:`,r);const n=this._procedureMap[a];if(!(n instanceof Function))throw new Error(`procedure \`${a}\`is not existed or is not a function`);const l=n(r);if(o(`[${this.label()}] callee: procedure \`${a}\`[${e}] returns value/promise:`,l),l instanceof Promise){const e=await l;i.value=e}else i.value=l;i.state="fulfilled"}catch(s){o(`[${this.label()}] callee: procedure \`${a}\`[${e}] throws error: ${s}`),i.error=s,i.state="rejected"}finally{this.postMessage(new t({payload:i,meta:this._messageMeta,type:s.RESPONSE}))}}_resolveResponse({uuid:e,value:s,name:t,error:r,state:a}){if(!this._requestMap[e])return void i(`[${this.label()}] caller: procedure \`${t}\`[${e}] is not matched`);const{resolve:n,reject:l}=this._requestMap[e];if(delete this._requestMap[e],"fulfilled"===a)o(`[${this.label()}] caller: procedure \`${t}\`[${e}] returns value:`,s,this),n(s);else{if("rejected"!==a)throw new Error(`unknow payload state: ${a}`);o(`[${this.label()}] caller: procedure \`${t}\`[${e}] throws error:`,r),l(r)}}}function a(){return(65536*(1+Math.random())|0).toString(16).substring(1)}function i(...e){console.warn("[RPC]",...e)}function o(...e){console.log("[RPC]",...e)}e.ServiceWorkerRPC=class extends r{constructor(){super(...arguments),this.label=()=>"service-worker-side"}async postMessage(e){const s=await self.clients.matchAll({type:"window"});for(const t of s)t.postMessage(e)}addMessageListener(e){self.addEventListener("message",e)}removeMessageListener(e){self.removeEventListener("message",e)}},e.WebRPC=class extends r{constructor(){super(...arguments),this.label=()=>"client-side"}async postMessage(e){(await navigator.serviceWorker.getRegistration())?.active?.postMessage(e)}addMessageListener(e){navigator.serviceWorker?.addEventListener("message",e)}removeMessageListener(e){navigator.serviceWorker?.removeEventListener("message",e)}},e.default=r,Object.defineProperty(e,"__esModule",{value:!0})}));
